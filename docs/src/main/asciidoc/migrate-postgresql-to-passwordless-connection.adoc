=== Migrate an application to use passwordless connections with Azure Database for PostgreSQL

This tutorial explains how to migrate from traditional authentication methods to more secure, passwordless connections with Azure Database for PostgreSQL.

Application requests to Azure Database for PostgreSQL must be authenticated. Azure Database for PostgreSQL provides several different ways for apps to connect securely. One of them is to use passwords. However, you should prioritize passwordless connections in your applications when possible.

==== Compare authentication options

When authenticating with Azure Database for PostgreSQL, the application provides a username and password pair to connect the database. Depending on where the identities are stored, there are two types of authentication: Azure Active Directory (Azure AD) authentication and PostgreSQL authentication.

===== Azure AD authentication

Microsoft Azure AD authentication is a mechanism for connecting to Azure Database for PostgreSQL using identities defined in Azure AD. With Azure AD authentication, you can manage database user identities and other Microsoft services in a central location, which simplifies permission management.

Using Azure AD for authentication provides the following benefits:

- Authentication of users across Azure Services in a uniform way.
- Management of password policies and password rotation in a single place.
- Multiple forms of authentication supported by Azure AD, which can eliminate the need to store passwords.
- Customers can manage database permissions using external (Azure AD) groups.
- Azure AD authentication uses PostgreSQL database users to authenticate identities at the database level.
- Support of token-based authentication for applications connecting to Azure Database for PostgreSQL.

===== PostgreSQL authentication

You can create accounts in PostgreSQL. If you choose to use passwords as credentials for the accounts, these credentials will be stored in the `user` table. Because these passwords are stored in PostgreSQL, you'll need to manage the rotation of the passwords by yourself.

Although it's possible to connect to Azure Database for PostgreSQL with passwords, you should use them with caution. You must be diligent to never expose the passwords in an unsecure location. Anyone who gains access to the passwords is able to authenticate. For example, if a password is accidentally checked into source control, sent through an unsecure email, pasted into the wrong chat, or viewed by someone who shouldn't have permission, there's risk of a malicious user accessing the application. Instead, consider updating your application to use passwordless connections.

==== Introducing passwordless connections

With a passwordless connection, you can connect to Azure services without storing any credentials in the application, its configuration files, or in environment variables.

To ensure that connections are passwordless, you must take into consideration both local development and the production environment. If a password is required in either place, then the application is not passwordless.

In your local development environment, you can authenticate with Azure CLI, Azure Powershell, Visual Studio, or Azure plugins for Visual Studio Code or IntelliJ. In this case, you can use that credential in your application instead of configuring properties.

When you deploy applications to an Azure hosting environment, such as a virtual machine, you can enable managed identity in that environment. Then, you won't need to provide credentials to connect to Azure services.

NOTE: A managed identity provides a security identity to represent an app or service. The identity is managed by the Azure platform and does not require you to provision or rotate any secrets. For more information, see link:https://learn.microsoft.com/azure/active-directory/managed-identities-azure-resources/overview[What are managed identities for Azure resources?]

==== Migrate an existing application to use passwordless connections

The following steps explain how to migrate an existing application to use passwordless connections instead of a password-based solution.

===== Prepare the working environment

First, use the following command to set up some environment variables.

[source,bash]
----
export AZ_RESOURCE_GROUP=<YOUR_RESOURCE_GROUP>
export AZ_DATABASE_SERVER_NAME=<YOUR_DATABASE_SERVER_NAME>
export AZ_DATABASE_NAME=demo
export AZ_POSTGRESQL_AD_NON_ADMIN_USERNAME=<YOUR_AZURE_AD_NON_ADMIN_USER_DISPLAY_NAME>
export AZ_POSTGRESQL_AD_MI_USERNAME=<YOUR_AZURE_AD_MI_DISPLAY_NAME>
export AZ_LOCAL_IP_ADDRESS=<YOUR_LOCAL_IP_ADDRESS>
export CURRENT_USERNAME=$(az ad signed-in-user show --query userPrincipalName --output tsv)
export CURRENT_USER_OBJECTID=$(az ad signed-in-user show --query id --output tsv)
----

Replace the placeholders with the following values, which are used throughout this article:

- `<YOUR_RESOURCE_GROUP>`: The name of the resource group your resources in.
- `<YOUR_DATABASE_SERVER_NAME>`: The name of your PostgreSQL server. It should be unique across Azure.
- `<YOUR_AZURE_AD_NON_ADMIN_USER_DISPLAY_NAME>`: The display name of your Azure AD non-admin user. Make sure the name is a valid user in your Azure AD tenant.
- `<YOUR_AZURE_AD_MI_DISPLAY_NAME>`: The display name of Azure AD user for your managed identity. Make sure the name is a valid user in your Azure AD tenant.
- `<YOUR_LOCAL_IP_ADDRESS>`: The IP address of your local computer, from which you'll run your Spring Boot application. One convenient way to find it is to open link:http://whatismyip.akamai.com[whatismyip.akamai.com].

===== Configure Azure Database for PostgreSQL

====== Enable Azure AD-based authentication

To use Azure Active Directory access with Azure Database for PostgreSQL, you should set the Azure AD admin user first. Only an Azure AD Admin user can create and enable users for Azure AD-based authentication.

If you're using Azure CLI, run the following command to make sure it has sufficient permission:

[source,bash]
----
az login --scope https://graph.microsoft.com/.default
----

Then, run following commands to set the Azure AD admin:

[source,bash]
----
az postgres server ad-admin create \
    --resource-group $AZ_RESOURCE_GROUP \
    --server-name $AZ_DATABASE_SERVER_NAME \
    --display-name $CURRENT_USERNAME \
    --object-id $CURRENT_USER_OBJECTID
----

This command will set the Azure AD admin to the current signed-in user.

NOTE: You can only create one Azure AD admin can be created per PostgreSQL server. Selection of another one will overwrite the existing Azure AD admin configured for the server.

===== Configure Azure Database for PostgreSQL for local development

====== Configure a firewall rule for local IP

Azure Database for PostgreSQL instances are secured by default. They have a firewall that doesn't allow any incoming connection. To be able to use your database, you need to add a firewall rule that will allow the local IP address to access the database server.

Because you configured your local IP address at the beginning of this article, you can open the server's firewall by running the following command:

[source,bash]
----
az postgres server firewall-rule create \
    --resource-group $AZ_RESOURCE_GROUP \
    --name $AZ_DATABASE_SERVER_NAME-database-allow-local-ip \
    --server $AZ_DATABASE_SERVER_NAME \
    --start-ip-address $AZ_LOCAL_IP_ADDRESS \
    --end-ip-address $AZ_LOCAL_IP_ADDRESS \
    --output tsv
----

If you're connecting to your PostgreSQL server from Windows Subsystem for Linux (WSL) on a Windows computer, you'll need to add the WSL host ID to your firewall.

Obtain the IP address of your host machine by running the following command in WSL:

[source,bash]
----
cat /etc/resolv.conf
----

Copy the IP address following the term `nameserver`, then use the following command to set an environment variable for the WSL IP Address:

[source,bash]
----
AZ_WSL_IP_ADDRESS=<the-copied-IP-address>
----

Then, use the following command to open the server's firewall to your WSL-based app:

[source,bash]
----
az PostgreSQL server firewall-rule create \
    --resource-group $AZ_RESOURCE_GROUP \
    --name $AZ_DATABASE_SERVER_NAME-database-allow-local-ip-wsl \
    --server $AZ_DATABASE_SERVER_NAME \
    --start-ip-address $AZ_WSL_IP_ADDRESS \
    --end-ip-address $AZ_WSL_IP_ADDRESS \
    --output tsv
----

====== Create a PostgreSQL non-admin user and grant permission

Next, create a non-admin Azure AD user and grant all permissions on the `$AZ_DATABASE_NAME` database to it. You can change the database name `$AZ_DATABASE_NAME` to fit your needs.

Create a SQL script called *create_ad_user_local.sql* for creating a non-admin user. Add the following contents and save it locally:

[source,bash]
----
cat << EOF > create_ad_user.sql
SET aad_validate_oids_in_tenant = off;
CREATE ROLE "$AZ_POSTGRESQL_AD_NON_ADMIN_USERNAME" WITH LOGIN IN ROLE azure_ad_user;
GRANT ALL PRIVILEGES ON DATABASE $AZ_DATABASE_NAME TO "$AZ_POSTGRESQL_AD_NON_ADMIN_USERNAME";
EOF
----

Then, use the following command to run the SQL script to create the Azure AD non-admin user:

[source,bash]
----
psql "host=$AZ_DATABASE_SERVER_NAME.postgres.database.azure.com user=$CURRENT_USERNAME@$AZ_DATABASE_SERVER_NAME dbname=$AZ_DATABASE_NAME port=5432 password=`az account get-access-token --resource-type oss-rdbms --output tsv --query accessToken` sslmode=require" < create_ad_user_local.sql
----

Now use the following command to remove the temporary SQL script file:

[source,bash]
----
rm create_ad_user_local.sql
----

NOTE: You can read more detailed information about creating PostgreSQL users in link:https://learn.microsoft.com/azure/PostgreSQL/single-server/how-to-create-users[Create users in Azure Database for PostgreSQL].

===== Sign in and migrate the app code to use passwordless connections

For local development, make sure you're authenticated with the same Azure AD account you assigned the role to on your PostgreSQL. You can authenticate via the Azure CLI, Visual Studio, Azure PowerShell, or other tools such as IntelliJ.

====== Azure CLI

Sign in to Azure through the Azure CLI by using the following command:

[source,bash]
----
az login
----

====== Visual Studio

Select the **Sign in** button in the top right corner of Visual Studio.

image:https://user-images.githubusercontent.com/58474919/192263363-9626e228-f8fa-4970-b3ef-0b04d07d236a.png[visual-studio]

Sign in using the Azure AD account you assigned a role to previously.

image:https://user-images.githubusercontent.com/58474919/192256652-0ae061e6-710f-4526-b8a5-77bb61d1a43a.png[visual-studio-sgin]

====== Visual Studio Code

Make sure you have the link:https://marketplace.visualstudio.com/items?itemName=ms-vscode.azure-account[Azure Account] extension installed.

image:https://user-images.githubusercontent.com/58474919/192256734-14715d5c-ff8e-4651-bd65-006591f4b148.png[Screenshot showing the Azure extension]

Use the **CTRL + Shift + P** shortcut to open the command palette. Search for the **Azure: Sign In** command and follow the prompts to authenticate. Make sure to use the Azure AD account you assigned a role to previously from your Blob Storage account.

image:https://user-images.githubusercontent.com/58474919/192256807-2b41033e-bbc5-4459-9b10-22f1e5141747.png[Screenshot showing the Azure sign-in command]

====== PowerShell

Sign in to Azure using PowerShell by using the following command:

[source,bash]
----
Connect-AzAccount
----

Next, use the following steps to update your code to use passwordless connections. Although conceptually similar, each language uses different implementation details.

====== Java

1. Inside your project, add the following reference to the `azure-identity-providers-jdbc-postgresql` package. This library contains all of the necessary entities to implement passwordless connections.
+
[source,xml]
----
   <dependency>
       <groupId>com.azure</groupId>
       <artifactId>azure-identity-providers-jdbc-postgresql</artifactId>
       <version>1.0.0-beta.1</version>
   </dependency>
----

2. Enable the Azure PostgreSQL authentication plugin in JDBC URL. Identify the locations in your code that currently create a `java.sql.Connection` to connect to Azure Database for PostgreSQL. Update `url` and `user` in your *application.properties* file to match the following values:
+
[source,properties]
----
   url=jdbc:postgresql://$AZ_DATABASE_SERVER_NAME.postgres.database.azure.com:5432/$AZ_DATABASE_NAME?sslmode=require&   authenticationPluginClassName=com.azure.identity.providers.postgresql.AzureIdentityPostgresqlAuthenticationPlugin
   user=$AZ_POSTGRESQL_AD_NON_ADMIN_USERNAME@$AZ_DATABASE_SERVER_NAME
----

3. Replace the `$AZ_POSTGRESQL_AD_NON_ADMIN_USERNAME` and the two `$AZ_DATABASE_SERVER_NAME` variables with the value that you configured at the beginning of this article.

====== Spring

1. Inside your project, add the following reference to the `spring-cloud-azure-starter-jdbc-postgresql` package. This library contains all of the necessary entities to implement passwordless connections.
+
[source,xml]
----
   <dependency>
       <groupId>com.azure.spring</groupId>
       <artifactId>spring-cloud-azure-starter-jdbc-postgresql</artifactId>
       <version>4.4.0-beta.1</version>
   </dependency>
----

2. Update the *application.yaml* or *application.properties* file as shown in the following example. Change the `spring.datasource.username` to the Azure AD user, remove the `spring.datasource.password` property, and add `spring.datasource.azure.passwordless-enabled=true`.

[source,yaml]
----
   spring:
     datasource:
       url: jdbc:postgresql://${AZ_DATABASE_SERVER_NAME}.postgres.database.azure.com:5432/$AZ_DATABASE_NAME?sslmode=require
       username: ${AZ_POSTGRESQL_AD_NON_ADMIN_USERNAME}@${AZ_DATABASE_SERVER_NAME}
       azure:
         passwordless-enabled: true
----

====== Run the app locally

After making these code changes, run your application locally. The new configuration should pick up your local credentials if you're signed in to a compatible IDE or command line tool, such as the Azure CLI, Visual Studio, or IntelliJ. The roles you assigned to your local dev user in Azure will allow your app to connect to the Azure service locally.

===== Configure the Azure hosting environment

Once your application is configured to use passwordless connections and it runs locally, the same code can authenticate to Azure services after it's deployed to Azure. For example, an application deployed to an Azure App Service instance that has a managed identity enabled can connect to Azure Storage.

====== Service Connector

Use the following command to create a service connection between an Azure Spring Apps service instance and an Azure database instance:

[source,bash]
----
az spring connection create postgres \
    --resource-group $AZ_RESOURCE_GROUP \
    --service <service-name> \
    --app <service-instance-name> \
    --target-resource-group $AZ_RESOURCE_GROUP \
    --server $AZ_DATABASE_SERVER_NAME \
    --database $AZ_DATABASE_NAME \
    --system-identity
----

This Service Connector command will do the following in the background:

- Enable system-assigned managed identity for the Azure Spring Apps instance `<service-instance-name>`.
- Set the Azure Active Directory admin to the current signed-in user.
- Add a database user named `<service-name>/apps/<service-instance-name>` for the managed identity created in step 1, and grant all privileges of the database `$AZ_DATABASE_NAME` to this user.
- Add two configurations to `<service-instance-name>`: `spring.datasource.url` and `spring.datasource.username`.

NOTE: If you see the error message `The subscription is not registered to use Microsoft.ServiceLinker`, run the command `az provider register --namespace Microsoft.ServiceLinker` to register the Service Connector resource provider, then run the connection command again.

====== Using the Azure portal

The following steps show you how to create a system-assigned managed identity for various web hosting services. The managed identity can securely connect to other Azure Services using the app configurations you set up previously.

* Azure App Service

1. On the main overview page of your Azure App Service instance, select **Identity** from the navigation pane.

2. On the **System assigned** tab, make sure to set the **Status** field to **on**. A system assigned identity is managed by Azure internally and handles administrative tasks for you. The details and IDs of the identity are never exposed in your code.
+
image:https://user-images.githubusercontent.com/58474919/192256885-b374e965-682f-47b8-a4d7-d227a01446c7.png[Screenshot of Azure portal Identity page of App Service resource with System assigned tab showing and Status field highlighted]

3. Copy the object (principal) ID.

4. You can assign a managed identity to an Azure App Service instance with the link:https://learn.microsoft.com/cli/azure/webapp/identity[az webapp identity assign] command, as shown in the following example:

[source,bash]
----
AZ_MI_OBJECT_ID=`az webapp identity assign --resource-group $AZ_RESOURCE_GROUP --name <service-instance-name> --query principalId --output tsv`
----

* Azure Container Apps

1. On the main overview page of your Azure Container Apps instance, select **Identity** from the navigation pane.

2. On the **System assigned** tab, make sure to set the **Status** field to **on**. A system assigned identity is managed by Azure internally and handles administrative tasks for you. The details and IDs of the identity are never exposed in your code.
+
image:https://user-images.githubusercontent.com/58474919/192256985-d3bc1029-7b37-4426-b618-7eba9388e59d.png[Screenshot of Azure portal Identity page of Container App resource showing System assigned tab with Status field highlighted]

3. Copy the object (principal) ID.

4. You can assign a managed identity to an Azure Container Apps instance with the link:https://learn.microsoft.com/cli/azure/containerapp/identity[az containerapp identity assign] command, as shown in the following example:

[source,bash]
----
AZ_MI_OBJECT_ID=`az containerapp identity assign --resource-group $AZ_RESOURCE_GROUP --name <service-instance-name> --query principalId --output tsv`
----

* Azure Spring Apps

1. On the main overview page of your Azure Spring Apps instance, select **Identity** from the navigation pane.

2. On the **System assigned** tab, make sure to set the **Status** field to **on**. A system assigned identity is managed by Azure internally and handles administrative tasks for you. The details and IDs of the identity are never exposed in your code.
+
image:https://user-images.githubusercontent.com/58474919/192257073-90a09aa6-396e-43f8-98fc-1a7d4eb37ac3.png[Screenshot of Azure portal Identity page of App resource with System assigned tab showing and Status field highlighted]

3. Copy the object (principal) ID.

4. You can assign a managed identity to an Azure Spring Apps instance with the link:https://learn.microsoft.com/cli/azure/spring/app/identity[az spring app identity assign] command, as shown in the following example:

[source,bash]
----
AZ_MI_OBJECT_ID=`az spring app identity assign --resource-group $AZ_RESOURCE_GROUP --name <service-instance-name> --service <service-name> --query identity.principalId --output tsv`
----

* Azure virtual machines

1. On the main overview page of your virtual machine, select **Identity** from the navigation pane.

2. On the **System assigned** tab, make sure to set the **Status** field to **on**. A system assigned identity is managed by Azure internally and handles administrative tasks for you. The details and IDs of the identity are never exposed in your code.
+
image:https://user-images.githubusercontent.com/58474919/192257152-801de5cb-7d5a-46fb-9580-cf024537cd9d.png[Screenshot of Azure portal Identity page of Virtual machine resource with System assigned tab showing and Status field highlighted]

3. Copy the object (principal) ID.

4. You can assign a managed identity to a virtual machine with the link:https://learn.microsoft.com/cli/azure/vm/identity[az vm identity assign] command, as shown in the following example:

[source,bash]
----
AZ_MI_OBJECT_ID=`az vm identity assign --resource-group $AZ_RESOURCE_GROUP --name <service-instance-name> --query principalId --output tsv`
----

* Azure Kubernetes Service

You can assign a managed identity to an Azure Kubernetes Service instance with the link:https://learn.microsoft.com/cli/azure/aks[az aks update] command, as shown in the following example:

[source,bash]
----
AZ_MI_OBJECT_ID=`az aks update --resource-group $AZ_RESOURCE_GROUP --name <AKS-cluster-name> --enable-managed-identity --query identityProfile.kubeletidentity.objectId --output tsv`
----

====== Assign roles to the managed identity

Next, grant permissions to the managed identity you created to access your PostgreSQL instance.

These steps will create an Azure AD user for the managed identity and grant all permissions for the database `$AZ_DATABASE_NAME` to it. You can change the database name `$AZ_DATABASE_NAME` to fit your needs.

First, create a SQL script called *create_ad_user_mi.sql* for creating a non-admin user. Add the following contents and save it locally:

[source,bash]
----
AZ_POSTGRESQL_AD_MI_USERID=`az ad sp show --id $AZ_MI_OBJECT_ID --query appId --output tsv`

cat << EOF > create_ad_user_mi.sql
SET aad_validate_oids_in_tenant = off;
CREATE ROLE "$AZ_POSTGRESQL_AD_MI_USERNAME" WITH LOGIN PASSWORD '$AZ_POSTGRESQL_AD_MI_USERID' IN ROLE azure_ad_user;
GRANT ALL PRIVILEGES ON DATABASE $AZ_DATABASE_NAME TO "$AZ_POSTGRESQL_AD_MI_USERNAME";
EOF
----

Then, use the following command to run the SQL script to create the Azure AD non-admin user:

[source,bash]
----
psql "host=$AZ_DATABASE_SERVER_NAME.postgres.database.azure.com user=$CURRENT_USERNAME@$AZ_DATABASE_SERVER_NAME dbname=$AZ_DATABASE_NAME port=5432 password=`az account get-access-token --resource-type oss-rdbms --output tsv --query accessToken` sslmode=require" < create_ad_user_mi.sql
----

Now use the following command to remove the temporary SQL script file:

[source,bash]
----
rm create_ad_user_mi.sql
----

====== Test the app

Before deploying the app to the hosting environment, you need to make one more change to the code because the application is going to connect to PostgreSQL using the user created for the managed identity.

* Java

Update your code to use the user created for the managed identity:

[source,java]
----
properties.put("user", "$AZ_POSTGRESQL_AD_MI_USERNAME@$AZ_DATABASE_SERVER_NAME");
----

* Spring

Update the *application.yaml* or *application.properties* file. Change the `spring.datasource.username` to the user created for the managed identity.

[source,yaml]
----
spring:
  datasource:
    url: jdbc:postgresql://${AZ_DATABASE_SERVER_NAME}.postgres.database.azure.com:5432/$AZ_DATABASE_NAME?sslmode=require
    username: ${AZ_POSTGRESQL_AD_MI_USERNAME}@${AZ_DATABASE_SERVER_NAME}
    azure:
      passwordless-enabled: true
----

After making these code changes, you can build and redeploy the application. Then, browse to your hosted application in the browser. Your app should be able to connect to the PostgreSQL database successfully. Keep in mind that it may take several minutes for the role assignments to propagate through your Azure environment. Your application is now configured to run both locally and in a production environment without the developers having to manage secrets in the application itself.
