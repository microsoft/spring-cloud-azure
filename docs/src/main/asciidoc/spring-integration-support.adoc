== Spring Integration Support

Spring Integration Extension for Azure provides Spring Integration adapters for the various services provided by the https://github.com/Azure/azure-sdk-for-java/[Azure SDK for Java]. Below is a list of supported adapters:

* spring-cloud-azure-starter-integration-eventhbus
* spring-cloud-azure-starter-integration-servicebus
* spring-cloud-azure-starter-integration-storage-queue

Provide Spring Integration support for these Azure services: Event Hubs, Service Bus, Storage Queue.

=== Spring Integration with Azure Event Hubs

==== Key concepts
Azure Event Hubs is a big data streaming platform and event ingestion service. It can receive and process millions of events per second. Data sent to an event hub can be transformed and stored by using any real-time analytics provider or batching/storage adapters.

Spring Integration enables lightweight messaging within Spring-based applications and supports integration with external systems via declarative adapters. Those adapters provide a higher-level of abstraction over Springâ€™s support for remoting, messaging, and scheduling. The *Spring Integration for Event Hubs* extension project provides inbound and outbound channel adapters and gateways for Azure Event Hubs.

NOTE: RxJava support APIs are dropped from version 4.0.0.
Please refer to Javadoc for details.

===== Consumer Group

Event Hubs provides similar support of consumer group as Apache Kafka, but with slight different logic. While Kafka
stores all committed offsets in the broker, you have to store offsets of Event Hubs messages
being processed manually. Event Hubs SDK provide the function to store such offsets inside Azure Storage Account. So
that's why you have to fill `spring.cloud.eventhubs.processor.checkpoint-store.*`.

===== Partitioning Support

Event Hubs provides a similar concept of physical partition as Kafka. But unlike Kafka's auto re-balancing between consumers and partitions, Event Hubs provides a kind of preemptive mode. The storage account acts as a lease to determine which partition is owned by which consumer. When a new consumer starts, it will try to steal some partitions
from most heavy-loaded consumers to achieve the workload balancing.

To specify the load balancing strategy, a bean of `com.azure.spring.messaging.PropertiesSupplier` should be provided with the key as the event hub name, and the value as `com.azure.spring.eventhubs.core.properties.ProcessorProperties` where the load balancing policy can be configured.

===== Batch Consumer Support
The `EventHubsInboundChannelAdapter` supports the batch-consuming mode. To enable it, users can specify the listener mode as `com.azure.spring.messaging.ListenerMode.BATCH` when construct an `EventHubsInboundChannelAdapter` instance.
When enabled, an **org.springframework.messaging.Message** of which the payload is a list of batched events will be received and passed to the consumer function. Each message header is also converted as a list, of which the content is the associated header value parsed from each event. For the communal headers of partition id, checkpointer and last enqueued properties, they are presented as a single value for the entire batch of events shares the same one. See <<si-eh-headers, Event Hubs Message Headers>> for more details.

NOTE: The checkpoint header only exists when **MANUAL** checkpoint mode is used.

Checkpointing of batch consumer supports two modes: `BATCH` and `MANUAL`. `BATCH` mode is an auto checkpointing mode to checkpoint the entire batch of events together once they are received. `MANUAL` mode is to checkpoint the events by users. When used, the
**com.azure.spring.messaging.checkpoint.Checkpointer** will be passes into the message header, and users could use it to do checkpointing.

The batch consuming policy can be specified by properties of `max-size` and `max-wait-time`, where `max-size` is a necessary property while `max-wait-time` is optional.
To specify the batch consuming strategy, a bean of `com.azure.spring.messaging.PropertiesSupplier` should be provided with the key as the event hub name, and the value as `com.azure.spring.eventhubs.core.properties.ProcessorProperties` where the batch consuming policy can be configured.

==== Dependency Setup

[source,xml]
----
<dependency>
	<groupId>com.azure.spring</groupId>
	<artifactId>spring-cloud-azure-starter-integration-eventhubs</artifactId>
</dependency>
----

==== Configuration

This starter provides the following 3 parts of configuration options:

[#eventhubs-connection-configration]
===== Connection Configuration Properties
These properties are exposed via `com.azure.spring.cloud.autoconfigure.eventhubs.properties.AzureEventHubsProperties`.

NOTE: If you choose to use a security principal to authenticate and authorize with Azure Active Directory for accessing an Azure resource, please refer to link:index.html#authorize-access-with-azure-active-directory[Authorize access with Azure AD] to make sure the security principal has been granted the sufficient permission to access the Azure resource.

.Connection configurable properties of spring-cloud-azure-starter-integration-eventhubs
[cols="<,<,<", options="header"]
|===
|Property | Type |Description

|*spring.cloud.azure.eventhubs*.enabled
| boolean
| Whether an Azure Event Hubs is enabled.

|*spring.cloud.azure.eventhubs*.connection-string
| String
| Event Hubs Namespace connection string value.

|*spring.cloud.azure.eventhubs*.namespace
| String
| Event Hubs Namespace value, which is the prefix of the FQDN. A FQDN should be composed of <NamespaceName>.<DomainName>

|*spring.cloud.azure.eventhubs*.domain-name
| String
| Domain name of an Azure Event Hubs Namespace value.

|*spring.cloud.azure.eventhubs*.custom-endpoint-address
| String
| Custom Endpoint address.

|*spring.cloud.azure.eventhubs*.shared-connection
| Boolean
| Whether the underlying EventProcessorClient and EventHubProducerAsyncClient use the same connection. By
default, a new connection is constructed and used created for each Event Hub client created.

|===

===== Checkpoint Configuration Properties
These properties are exposed via `com.azure.spring.cloud.autoconfigure.eventhubs.properties.AzureEventHubsProperties.Processor.BlobCheckpointStore`
for the configuration of `BlobCheckpointStore`, which is the default implementation of `CheckpointStore` to use Storage Blobs for persisting partition ownership and checkpoint information.

NOTE: From version 4.0.0, when the property of **spring.cloud.azure.eventhubs.processor.checkpoint-store.create-container-if-not-exists** is not enabled manually, no Storage container will be created automatically.

.Checkpointing configurable properties of spring-cloud-azure-starter-integration-eventhubs
[cols="<,<,<", options="header"]
|===
|Property | Type |Description

|*spring.cloud.azure.eventhubs.processor.checkpoint-store*.create-container-if-not-exists
|Boolean
|If allowed creating containers if not exists.

|*spring.cloud.azure.eventhubs.processor.checkpoint-store*.account-name
| String
| Name for the storage account.

|*spring.cloud.azure.eventhubs.processor.checkpoint-store*.account-key
| String
| Storage account access key.

|*spring.cloud.azure.eventhubs.processor.checkpoint-store*.container-name
| String
| Storage container name.
|===

Common Azure Service SDK configuration options are configurable for Storage Blob checkpoint store as well. The supported configuration options are introduced in link:configuration.html[the Configuration page], and could be configured with either the unified prefix `spring.cloud.azure.` or the prefix of `spring.cloud.azure.eventhubs.processor.checkpoint-store`.

NOTE: The default maximum connection pool size of the Storage Blob client is changed from `500` in version 3.x to `16` now, and the pending acquire queue size which is double of pool size is then `32` now. To override them, please set the property `spring.cloud.azure.eventhubs.processor.checkpoint-store.client.maximum-connection-pool-size`.

===== Event Hub Processor Configuration Properties

The `EventHubsInboundChannelAdapter` uses the `EventProcessorClient` to consume messages from an Event Hub, to configure the overall properties of an `EventProcessorClient`,
developers can use `com.azure.spring.messaging.eventhubs.core.properties.EventHubsContainerProperties` for the configuration for the user-defined bean of
`com.azure.spring.messaging.eventhubs.core.listener.EventHubsMessageListenerContainer`. See <<receive-from-eh, the below section>> about how to work with `EventHubsInboundChannelAdapter`.

==== Basic Usage
===== Send messages to Azure Event Hubs
Step 1. Fill the credential configuration options.

* For credentials as connection string, configure below properties in `application.yml`:
[source,yaml]
----
spring:
  cloud:
    azure:
      eventhubs:
        connection-string: ${AZURE_SERVICE_BUS_CONNECTION_STRING}
        processor:
          checkpoint-store:
            container-name: ${CHECKPOINT-CONTAINER}
            account-name: ${CHECKPOINT-STORAGE-ACCOUNT}
            account-key: ${CHECKPOINT-ACCESS-KEY}
----

* For credentials as MSI, configure below properties in `application.yml`:
[source,yaml]
----
spring:
  cloud:
    azure:
      credential:
        managed-identity-client-id: ${AZURE_CLIENT_ID}
      eventhubs:
        namespace: ${AZURE_SERVICE_BUS_NAMESPACE}
        processor:
          checkpoint-store:
            container-name: ${CONTAINER_NAME}
            account-name: ${ACCOUNT_NAME}
----

* For credentials as service principal, configure below properties in application.yml:
[source,yaml]
----
spring:
  cloud:
    azure:
      credential:
        client-id: ${AZURE_CLIENT_ID}
        client-secret: ${AZURE_CLIENT_SECRET}
      profile:
        tenant-id: ${AZURE_TENANT_ID}
      eventhubs:
        namespace: ${AZURE_SERVICE_BUS_NAMESPACE}
        processor:
          checkpoint-store:
            container-name: ${CONTAINER_NAME}
            account-name: ${ACCOUNT_NAME}
----

Step 2. Create `DefaultMessageHandler` with the bean of `EventHubsTemplate` to send messages to Event Hubs.
[source,java]
----
class Demo{
    private static final String OUTPUT_CHANNEL = "output";
    private static final String EVENTHUB_NAME = "eh1";

    @Bean
    @ServiceActivator(inputChannel = OUTPUT_CHANNEL)
    public MessageHandler messageSender(EventHubsTemplate eventHubsTemplate) {
        DefaultMessageHandler handler = new DefaultMessageHandler(EVENTHUB_NAME, eventHubsTemplate);
        handler.setSendCallback(new ListenableFutureCallback<Void>() {
            @Override
            public void onSuccess(Void result) {
                LOGGER.info("Message was sent successfully.");
            }
            @Override
            public void onFailure(Throwable ex) {
                LOGGER.error("There was an error sending the message.", ex);
            }
        });
        return handler;
    }
}
----

Step 3. Create a Message gateway binding with the message handler created in the last step via a message channel
[source,java]
----
class Demo{
    @Autowired
    EventHubOutboundGateway messagingGateway;

    @MessagingGateway(defaultRequestChannel = OUTPUT_CHANNEL)
    public interface EventHubOutboundGateway {
        void send(String text);
    }
}
----
Step 4. Send messages using the gateway
[source,java]
----
class Demo{
    public void demo() {
        this.messagingGateway.send(message);
    }
}
----

[#receive-from-eh]
===== Receive messages from Azure Event Hubs
Step 1. Fill the credential configuration options.

Step 2. Create a bean of message channel as the input channel.
[source,java]
----
class Demo{
    @Bean
    public MessageChannel input() {
        return new DirectChannel();
    }
}
----

Step 3. Create `EventHubsInboundChannelAdapter` with the bean of `EventHubsMessageListenerContainer` to receive messages to Event Hubs.

[source,java]
----
@Configuration
class Demo{
    private static final String INPUT_CHANNEL = "input";
    private static final String EVENTHUB_NAME = "eh1";
    private static final String CONSUMER_GROUP = "$Default";

    @Bean
    public EventHubsInboundChannelAdapter messageChannelAdapter(
            @Qualifier(INPUT_CHANNEL) MessageChannel inputChannel,
            EventHubsMessageListenerContainer listenerContainer) {
        EventHubsInboundChannelAdapter adapter = new EventHubsInboundChannelAdapter(processorContainer);
        adapter.setOutputChannel(inputChannel);
        return adapter;
    }

    @Bean
    public EventHubsMessageListenerContainer messageListenerContainer(EventHubsProcessorFactory processorFactory) {
        EventHubsContainerProperties containerProperties = new EventHubsContainerProperties();
        containerProperties.setEventHubName(EVENTHUB_NAME);
        containerProperties.setConsumerGroup(CONSUMER_GROUP);
        CheckpointConfig config = new CheckpointConfig(CheckpointMode.MANUAL);
        containerProperties.setCheckpointConfig(config);
        return new EventHubsMessageListenerContainer(processorFactory, containerProperties);
    }
}
----

Step 4. Create a message receiver binding with EventHubsInboundChannelAdapter created in the last step via the message channel we created before.
[source,java]
----
class Demo{
    @ServiceActivator(inputChannel = INPUT_CHANNEL)
    public void messageReceiver(byte[] payload, @Header(AzureHeaders.CHECKPOINTER) Checkpointer checkpointer) {
        String message = new String(payload);
        LOGGER.info("New message received: '{}'", message);
        checkpointer.success()
                .doOnSuccess(s -> LOGGER.info("Message '{}' successfully checkpointed", message))
                .doOnError(e -> LOGGER.error("Error found", e))
                .subscribe();
    }
}
----

===== Configure EventHubsMessageConverter to customize ObjectMapper
`EventHubsMessageConverter` is made as a configurable bean to allow users to customize ObjectMapper.

[#si-eh-batch]
===== Batch Consumer Support
To consume messages from Event Hubs in batches is similar with the above sample, besides users should set the batch-consuming related configuration options for `EventHubsInboundChannelAdapter`.

When create `EventHubsInboundChannelAdapter`, the listener mode should be set as `BATCH`. And set the checkpoint mode as either `MANUAL`
or `BATCH` as needed.

[source,java]
----
@Bean
class Demo{
    private static final String INPUT_CHANNEL = "input";
    private static final String EVENTHUB_NAME = "eh1";
    private static final String CONSUMER_GROUP = "$Default";

    public EventHubsInboundChannelAdapter messageChannelAdapter(
            @Qualifier(INPUT_CHANNEL) MessageChannel inputChannel,
            EventHubsProcessorContainer processorContainer) {
        //Supported checkpoint modes are MANUAL AND BATCH only.
        CheckpointConfig config = new CheckpointConfig(CheckpointMode.MANUAL);

        EventHubsInboundChannelAdapter adapter =
                new EventHubsInboundChannelAdapter(processorContainer, EVENTHUB_NAME,
                        CONSUMER_GROUP, ListenerMode.BATCH, config);
        adapter.setOutputChannel(inputChannel);
        return adapter;
    }
}
----

Then a bean of `com.azure.spring.messaging.PropertiesSupplier` should be provided with the key as the event hub name, and the value as `com.azure.spring.eventhubs.core.properties.ProcessorProperties` where the batch consuming policy can be configured.

[#si-eh-headers]
===== Event Hubs message headers

The following table illustrates how Event Hubs message properties are mapped to Spring message headers. For Azure Event Hubs, message is called as `event`.

.Mapping between Record Event Hubs Properties and Spring Headers
[cols="<,<,<,<", options="header"]
|===
|Event Hubs Event Properties | Spring Message Header Constants | Type | Description

|Enqueued time
|com.azure.spring.eventhubs.support.EventHubsHeaders#ENQUEUED_TIME
|Instant
|The instant, in UTC, of when the event was enqueued in the Event Hub partition.

|Offset
|com.azure.spring.eventhubs.support.EventHubsHeaders#OFFSET
|Long
|The offset of the event when it was received from the associated Event Hub partition.

|Partition key
|com.azure.spring.messaging.AzureHeaders#PARTITION_KEY
|String
|The partition hashing key if it was set when originally publishing the event.

|Partition id
|com.azure.spring.messaging.AzureHeaders#RAW_PARTITION_ID
|String
|The partition id of the Event Hub.

|Sequence number
|com.azure.spring.eventhubs.support.EventHubsHeaders#SEQUENCE_NUMBER
|Long
|The sequence number assigned to the event when it was enqueued in the associated Event Hub partition.

|Last enqueued event properties
|com.azure.spring.eventhubs.support.EventHubsHeaders#LAST_ENQUEUED_EVENT_PROPERTIES
|LastEnqueuedEventProperties
|The properties of the last enqueued event in this partition.

|NA
|com.azure.spring.messaging.AzureHeaders#CHECKPOINTER
|com.azure.spring.messaging.checkpoint.Checkpointer
|The header for checkpoint the specific message.
|===

Users can parse the message headers for the related information of each event. To set a message header for the event, all customized headers will be put as an application property of an event, where the header is set as the property key. When events are received from Event Hubs, all application properties will be converted to the message header.

NOTE: Message headers of partition key, enqueued time, offset and sequence number is not supported to be set manually.

When the batch-consumer mode is enabled, the specific headers of batched messages are listed as below, which contains a list of values from each single Event Hubs event.

.Mapping between Batch Event Hubs Properties and Spring Headers
[cols="<,<,<,<", options="header"]
|===
|Event Hubs Event Properties | Spring Batch Message Header Constants | Type | Description

|Enqueued time
|com.azure.spring.eventhubs.support.EventHubsHeaders#ENQUEUED_TIME
|List of Instant
|List of the instant, in UTC, of when each event was enqueued in the Event Hub partition.

|Offset
|com.azure.spring.eventhubs.support.EventHubsHeaders#OFFSET
|List of Long
|List of the offset of each event when it was received from the associated Event Hub partition.

|Partition key
|ccom.azure.spring.messaging.AzureHeaders#PARTITION_KEY
|List of String
|List of the partition hashing key if it was set when originally publishing each event.

|Sequence number
|com.azure.spring.eventhubs.support.EventHubsHeaders#SEQUENCE_NUMBER
|List of Long
|List of the sequence number assigned to each event when it was enqueued in the associated Event Hub partition.

|System properties
|com.azure.spring.eventhubs.support.EventHubsHeaders#BATCH_CONVERTED_SYSTEM_PROPERTIES
|List of Map
|List of the system properties of each event.

|Application properties
|com.azure.spring.eventhubs.support.EventHubsHeaders#BATCH_CONVERTED_APPLICATION_PROPERTIES
|List of Map
|List of the applocation properties of each event, where all customized message headers or event properties are placed.
|===

==== Samples

Please refer to link:https://github.com/Azure-Samples/azure-spring-boot-samples/tree/spring-cloud-azure_{project-version}/eventhubs/spring-cloud-azure-starter-integration-eventhubs/eventhubs-integration[azure-spring-boot-samples] for more details.

=== Spring Integration with Azure Service Bus

==== Key concepts
Spring Integration enables lightweight messaging within Spring-based applications and supports integration with external systems via declarative adapters.

The Spring Integration for Azure Service Bus extension project provides inbound and outbound channel adapters for Azure Service Bus.

NOTE: CompletableFuture support APIs have been deprecated from version 2.10.0, and is replaced by Reactor Core from version 4.0.0.
Please refer to Javadoc for details.

==== Dependency Setup

[source,xml]
----
<dependency>
	<groupId>com.azure.spring</groupId>
	<artifactId>spring-cloud-azure-starter-integration-servicebus</artifactId>
</dependency>
----

==== Configuration

This starter provides the following 2 parts of configuration options:

[#eventhubs-connection-configration]
===== Connection Configuration Properties

These properties are exposed via `com.azure.spring.cloud.autoconfigure.implementation.servicebus.properties.AzureServiceBusProperties`.

NOTE: If you choose to use a security principal to authenticate and authorize with Azure Active Directory for accessing an Azure resource, please refer to link:index.html#authorize-access-with-azure-active-directory[Authorize access with Azure AD] to make sure the security principal has been granted the sufficient permission to access the Azure resource.

.Connection configurable properties of spring-cloud-azure-starter-integration-servicebus
[cols="<,<,<", options="header"]
|===
|Property | Type |Description

|*spring.cloud.azure.servicebus*.enabled
| boolean
| Whether an Azure Service Bus is enabled.

|*spring.cloud.azure.servicebus*.connection-string
| String
| Service Bus Namespace connection string value.

|*spring.cloud.azure.servicebus*.namespace
| String
| Service Bus Namespace value, which is the prefix of the FQDN. A FQDN should be composed of <NamespaceName>.<DomainName>

|*spring.cloud.azure.servicebus*.domain-name
| String
| Domain name of an Azure Service Bus Namespace value.

|===

===== Service Bus Processor Configuration Properties

The `ServiceBusInboundChannelAdapter` uses the `ServiceBusProcessorClient` to consume messages, to configure the overall properties of an `ServiceBusProcessorClient`,
developers can use `com.azure.spring.messaging.servicebus.core.properties.ServiceBusContainerProperties` for the configuration for the user-defined bean of
`com.azure.spring.messaging.servicebus.core.listener.ServiceBusMessageListenerContainer`. See <<receive-from-sb, the below section>> about how to work with `ServiceBusInboundChannelAdapter`.

==== Basic Usage
===== Send messages to Azure Service Bus
Step 1. Fill the credential configuration options.

* For credentials as connection string, configure below properties in application.yml:
[source,yaml]
----
spring:
  cloud:
    azure:
      servicebus:
        connection-string: ${AZURE_SERVICE_BUS_CONNECTION_STRING}
----

* For credentials as MSI, configure below properties in application.yml:
[source,yaml]
----
spring:
  cloud:
    azure:
      credential:
        managed-identity-client-id: ${AZURE_CLIENT_ID}
      profile:
        tenant-id: ${AZURE_TENANT_ID}
      servicebus:
        namespace: ${AZURE_SERVICE_BUS_NAMESPACE}
----

* For credentials as service principal, configure below properties in application.yml:
[source,yaml]
----
spring:
  cloud:
    azure:
      credential:
        client-id: ${AZURE_CLIENT_ID}
        client-secret: ${AZURE_CLIENT_SECRET}
      profile:
        tenant-id: ${AZURE_TENANT_ID}
      servicebus:
        namespace: ${AZURE_SERVICE_BUS_NAMESPACE}
----

Step 2. Create `DefaultMessageHandler` with the bean of `ServiceBusTemplate` to send messages to Service Bus,
set the entity type for the ServiceBusTemplate. This sample takes Service Bus Queue as example.
[source,java]
----
class Demo{
    private static final String OUTPUT_CHANNEL = "queue.output";

    @Bean
    @ServiceActivator(inputChannel = OUTPUT_CHANNEL)
    public MessageHandler queueMessageSender(ServiceBusTemplate serviceBusTemplate) {
        serviceBusTemplate.setDefaultEntityType(ServiceBusEntityType.QUEUE);
        DefaultMessageHandler handler = new DefaultMessageHandler(QUEUE_NAME, serviceBusTemplate);
        handler.setSendCallback(new ListenableFutureCallback<Void>() {
            @Override
            public void onSuccess(Void result) {
                LOGGER.info("Message was sent successfully.");
            }

            @Override
            public void onFailure(Throwable ex) {
                LOGGER.info("There was an error sending the message.");
            }
        });

        return handler;
    }
}
----

Step 3. Create a Message gateway binding with the message handler created in the last stop via a message channel
[source,java]
----
class Demo{
    @Autowired
    QueueOutboundGateway messagingGateway;

    @MessagingGateway(defaultRequestChannel = OUTPUT_CHANNEL)
    public interface QueueOutboundGateway {
        void send(String text);
    }
}
----

Step 4. Send messages using the gateway
[source,java]
----
class Demo{
    public void demo() {
        this.messagingGateway.send(message);
    }
}
----

[#receive-from-sb]
===== Receive messages from Azure Service Bus
Step 1. Fill the credential configuration options.

Step 2. Create a bean of message channel as the input channel.
[source,java]
----
class Demo{
    private static final String INPUT_CHANNEL = "input";

    @Bean
    public MessageChannel input() {
        return new DirectChannel();
    }
}
----

Step 3. Create `ServiceBusInboundChannelAdapter` with the bean of `ServiceBusMessageListenerContainer` to receive messages to Service Bus. This sample takes Service Bus Queue as example.
[source,java]
----
@Configuration
class Demo{
    private static final String QUEUE_NAME = "queue1";

    @Bean
    public ServiceBusMessageListenerContainer messageListenerContainer(ServiceBusProcessorFactory processorFactory) {
        ServiceBusContainerProperties containerProperties = new ServiceBusContainerProperties();
        containerProperties.setEntityName(QUEUE_NAME);
        CheckpointConfig checkpointConfig = new CheckpointConfig(CheckpointMode.MANUAL);
        containerProperties.setCheckpointConfig(checkpointConfig);
        return new ServiceBusMessageListenerContainer(processorFactory, containerProperties);
    }

    @Bean
    public ServiceBusInboundChannelAdapter queueMessageChannelAdapter(
        @Qualifier(INPUT_CHANNEL) MessageChannel inputChannel,
        ServiceBusMessageListenerContainer listenerContainer) {
        ServiceBusInboundChannelAdapter adapter = new ServiceBusInboundChannelAdapter(listenerContainer);
        adapter.setOutputChannel(inputChannel);
        return adapter;
    }
}
----

Step 4. Create a message receiver binding with ServiceBusInboundChannelAdapter created in the last step via the message channel we created before.
[source,java]
----
class Demo{
    @ServiceActivator(inputChannel = INPUT_CHANNEL)
    public void messageReceiver(byte[] payload, @Header(AzureHeaders.CHECKPOINTER) Checkpointer checkpointer) {
        String message = new String(payload);
        LOGGER.info("New message received: '{}'", message);
        checkpointer.success()
                .doOnSuccess(s -> LOGGER.info("Message '{}' successfully checkpointed", message))
                .doOnError(e -> LOGGER.error("Error found", e))
                .subscribe();
    }
}
----

===== Configure ServiceBusMessageConverter to customize ObjectMapper
`ServiceBusMessageConverter` is made as a configurable bean to allow users to customize ObjectMapper.

[#si-sb-headers]
===== Service Bus message headers
For some Service Bus headers that can be mapped to multiple Spring header constants, the priority of different Spring headers is listed.

.Mapping between Service Bus Headers and Spring Headers
[cols="<,<,<,<", options="header"]
|===
|Service Bus Message Headers and Properties | Spring Message Header Constants | Type | Priority Number (Descending priority)

|ContentType
| org.springframework.messaging.MessageHeaders.CONTENT_TYPE
| String
| N/A

|CorrelationId
| com.azure.spring.servicebus.support.ServiceBusMessageHeaders.CORRELATION_ID
|String
| N/A

|**MessageId**
| com.azure.spring.servicebus.support.ServiceBusMessageHeaders.MESSAGE_ID
| String
| 1

|**MessageId**
| com.azure.spring.messaging.AzureHeaders.RAW_ID
| String
| 2

|**MessageId**
| org.springframework.messaging.MessageHeaders.ID
| UUID
| 3

|PartitionKey
| com.azure.spring.servicebus.support.ServiceBusMessageHeaders.PARTITION_KEY
|String
| N/A

|ReplyTo
| org.springframework.messaging.MessageHeaders.REPLY_CHANNEL
| String
| N/A

|ReplyToSessionId
| com.azure.spring.servicebus.support.ServiceBusMessageHeaders.REPLY_TO_SESSION_ID
| String
| N/A

|**ScheduledEnqueueTimeUtc**
| com.azure.spring.messaging.AzureHeaders.SCHEDULED_ENQUEUE_MESSAGE
| Integer
| 1

|**ScheduledEnqueueTimeUtc**
| com.azure.spring.servicebus.support.ServiceBusMessageHeaders.SCHEDULED_ENQUEUE_TIME
| Instant
| 2

|SessionID
| com.azure.spring.servicebus.support.ServiceBusMessageHeaders.SESSION_ID
| String
| N/A

|TimeToLive
| com.azure.spring.servicebus.support.ServiceBusMessageHeaders.TIME_TO_LIVE
|Duration
| N/A

|To
| com.azure.spring.servicebus.support.ServiceBusMessageHeaders.TO
| String
| N/A
|===

===== Partition key support
This starter supports link:https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning[Service Bus partitioning] by allowing setting partition key and session id in the message header. This section introduces how to set partition key for messages.

_Recommended:_ Use `ServiceBusMessageHeaders.PARTITION_KEY` as the key of the header.

[source,java]
----
public class SampleController {
    @PostMapping("/messages")
    public ResponseEntity<String> sendMessage(@RequestParam String message) {
        LOGGER.info("Going to add message {} to Sinks.Many.", message);
        many.emitNext(MessageBuilder.withPayload(message)
                                    .setHeader(ServiceBusMessageHeaders.PARTITION_KEY, "Customize partition key")
                                    .build(), Sinks.EmitFailureHandler.FAIL_FAST);
        return ResponseEntity.ok("Sent!");
    }
}
----

_Not recommended but currently supported:_ `AzureHeaders.PARTITION_KEY` as the key of the header.

[source,java]
----
public class SampleController {
    @PostMapping("/messages")
    public ResponseEntity<String> sendMessage(@RequestParam String message) {
        LOGGER.info("Going to add message {} to Sinks.Many.", message);
        many.emitNext(MessageBuilder.withPayload(message)
                                    .setHeader(AzureHeaders.PARTITION_KEY, "Customize partition key")
                                    .build(), Sinks.EmitFailureHandler.FAIL_FAST);
        return ResponseEntity.ok("Sent!");
    }
}
----

NOTE: When both `ServiceBusMessageHeaders.PARTITION_KEY` and `AzureHeaders.PARTITION_KEY` are set in the message headers,
`ServiceBusMessageHeaders.PARTITION_KEY` is preferred.

===== Session support

This example demonstrates how to manually set the session id of a message in the application.

[source,java]
----
public class SampleController {
    @PostMapping("/messages")
    public ResponseEntity<String> sendMessage(@RequestParam String message) {
        LOGGER.info("Going to add message {} to Sinks.Many.", message);
        many.emitNext(MessageBuilder.withPayload(message)
                                    .setHeader(ServiceBusMessageHeaders.SESSION_ID, "Customize session id")
                                    .build(), Sinks.EmitFailureHandler.FAIL_FAST);
        return ResponseEntity.ok("Sent!");
    }
}
----

NOTE: When the `ServiceBusMessageHeaders.SESSION_ID` is set in the message headers, and a different `ServiceBusMessageHeaders.PARTITION_KEY` (or `AzureHeaders.PARTITION_KEY`) header is also set,
the value of the session id will eventually be used to overwrite the value of the partition key.

==== Samples

Please refer to link:https://github.com/Azure-Samples/azure-spring-boot-samples/tree/spring-cloud-azure_{project-version}/servicebus/spring-cloud-azure-starter-integration-servicebus[azure-spring-boot-samples] for more details.

=== Spring Integration with Azure Storage Queue

==== Key concepts
Azure Queue Storage is a service for storing large numbers of messages. You access messages from anywhere in the world via authenticated calls using HTTP or HTTPS. A queue message can be up to 64 KB in size. A queue may contain millions of messages, up to the total capacity limit of a storage account. Queues are commonly used to create a backlog of work to process asynchronously.

==== Dependency Setup

[source,xml]
----
<dependency>
	<groupId>com.azure.spring</groupId>
	<artifactId>spring-cloud-azure-starter-integration-storage-queue</artifactId>
</dependency>
----

==== Configuration

[#storage-queue-connection-configration]
===== Connection Configuration Properties
These properties are exposed via `com.azure.spring.cloud.autoconfigure.implementation.storage.queue.properties.AzureStorageQueueProperties`.

.Connection configurable properties of spring-cloud-azure-starter-integration-storage-queue
[cols="<,<,<", options="header"]
|===
|Property | Type |Description

|*spring.cloud.azure.storage.queue*.enabled | boolean | Whether an Azure Storage Queue is enabled.
|*spring.cloud.azure.storage.queue*.connection-string | String | Storage Queue Namespace connection string value.
|*spring.cloud.azure.storage.queue*.accountName | String | Storage Queue account name.
|*spring.cloud.azure.storage.queue*.accountKey | String | Storage Queue account key.
|*spring.cloud.azure.storage.queue*.endpoint | String | Storage Queue service endpoint.
|*spring.cloud.azure.storage.queue*.sasToken | String | Sas token credential
|*spring.cloud.azure.storage.queue*.serviceVersion | QueueServiceVersion | QueueServiceVersion that is used when making API requests.
|*spring.cloud.azure.storage.queue*.messageEncoding | String | Queue message encoding.

|===

NOTE: If you choose to use a security principal to authenticate and authorize with Azure Active Directory for accessing an Azure resource, please refer to link:index.html#authorize-access-with-azure-active-directory[Authorize access with Azure AD] to make sure the security principal has been granted the sufficient permission to access the Azure resource.

==== Basic Usage
===== Send messages to Azure Storage Queue
Step 1. Fill the credential configuration options.

** For credentials as connection string, configure below properties in application.yml:
[source,yaml]
----
spring:
  cloud:
    azure:
      storage:
        queue:
          connection-string: ${AZURE_SERVICE_BUS_CONNECTION_STRING}
----

** For credentials as MSI, configure below properties in application.yml:
[source,yaml]
----
spring:
  cloud:
    azure:
      credential:
        managed-identity-client-id: ${AZURE_CLIENT_ID}
      profile:
        tenant-id: ${AZURE_TENANT_ID}
      storage:
        queue:
          namespace: ${AZURE_SERVICE_BUS_NAMESPACE}
----

** For credentials as service principal, configure below properties in application.yml:
[source,yaml]
----
spring:
  cloud:
    azure:
      credential:
        client-id: ${AZURE_CLIENT_ID}
        client-secret: ${AZURE_CLIENT_SECRET}
      profile:
        tenant-id: ${AZURE_TENANT_ID}
      storage:
        queue:
          namespace: ${AZURE_SERVICE_BUS_NAMESPACE}
----


Step 2. Create `DefaultMessageHandler` with the bean of `StorageQueueTemplate` to send messages to Storage Queue.
[source,java]
----
class Demo{
    private static final String STORAGE_QUEUE_NAME = "example";
    private static final String OUTPUT_CHANNEL = "output";

    @Bean
    @ServiceActivator(inputChannel = OUTPUT_CHANNEL)
    public MessageHandler messageSender(StorageQueueTemplate storageQueueTemplate) {
        DefaultMessageHandler handler = new DefaultMessageHandler(STORAGE_QUEUE_NAME, storageQueueTemplate);
        handler.setSendCallback(new ListenableFutureCallback<Void>() {
            @Override
            public void onSuccess(Void result) {
                LOGGER.info("Message was sent successfully.");
            }

            @Override
            public void onFailure(Throwable ex) {
                LOGGER.info("There was an error sending the message.");
            }
        });
        return handler;
    }
}
----

Step 3. Create a Message gateway binding with the message handler created in the last stop via a message channel
[source,java]
----
class Demo{
    @Autowired
    StorageQueueOutboundGateway storageQueueOutboundGateway;

    @MessagingGateway(defaultRequestChannel = OUTPUT_CHANNEL)
    public interface StorageQueueOutboundGateway {
        void send(String text);
    }
}
----

Step 4. Send messages using the gateway
[source,java]
----
class Demo{
    public void demo() {
        this.storageQueueOutboundGateway.send(message);
    }
}
----

===== Receive messages from Azure Storage Queue
Step 1. Fill the credential configuration options.

Step 2. Create a bean of message channel as the input channel.
[source,java]
----
class Demo{
    private static final String INPUT_CHANNEL = "input";

    @Bean
    public MessageChannel input() {
        return new DirectChannel();
    }
}
----

Step 3. Create `StorageQueueMessageSource` with the bean of `StorageQueueTemplate` to receive messages to Storage Queue.
[source,java]
----
class Demo{
    private static final String STORAGE_QUEUE_NAME = "example";

    @Bean
    @InboundChannelAdapter(channel = INPUT_CHANNEL, poller = @Poller(fixedDelay = "1000"))
    public StorageQueueMessageSource storageQueueMessageSource(StorageQueueTemplate storageQueueTemplate) {
        return new StorageQueueMessageSource(STORAGE_QUEUE_NAME, storageQueueTemplate);
    }
}
----

Step 4. Create a message receiver binding with StorageQueueMessageSource created in the last step via the message channel we created before.
[source,java]
----
class Demo{
    @ServiceActivator(inputChannel = INPUT_CHANNEL)
    public void messageReceiver(byte[] payload, @Header(AzureHeaders.CHECKPOINTER) Checkpointer checkpointer) {
        String message = new String(payload);
        LOGGER.info("New message received: '{}'", message);
        checkpointer.success()
            .doOnError(Throwable::printStackTrace)
            .doOnSuccess(t -> LOGGER.info("Message '{}' successfully checkpointed", message))
            .subscribe();
    }
}
----

==== Samples

Please refer to link:https://github.com/Azure-Samples/azure-spring-boot-samples/tree/spring-cloud-azure_{project-version}/storage/spring-cloud-azure-starter-integration-storage-queue[azure-spring-boot-samples] for more details.

